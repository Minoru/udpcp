# Требования

- Linux x86_64
- gcc >= 4.9 (C++11)

# Сборка

```
$ make
```

# Запуск

```
$ make run -j5
```

`-j5` позволяет серверу и четырём клиентам запуститься одновременно.

В выводе можно видеть следующую информацию:

```
data/16195 is 16195 bytes long, so 12 chunks, the last one is 3 bytes long
```

Клиент запустился, прочёл файл и подсчитал количество пакетов, которые нужно
отправить. Длина всех пакетов, кроме последнего, фиксирована — 1472 байта.

```
<-- (data/16195, 1786814329923273199) Sent chunk #6
```

Клиент отправил указанный кусочек указанного файла. Также виден цифровой ID,
назначенный этому файлу; он пригодится при чтении логов сервера.

```
-->     seq_number = 6  seq_total = 12  type = 1        id = 1786814329923273199        and 1472 bytes of data
        got 1 out of 12 chunks
```

Сервер принял указанный кусочек файла. Видны все поля пакета, а также количество
содержащихся в нём данных. Во второй строке указано, сколько пакетов уже
получено.

```
Received a file id = 2447301909556127264, 1 bytes, checksum 0x399f7b69
```

Сервер закончил приём файла с указанным идентификатором и вычислил его
контрольную сумму.

```
 OK  Sent data/1 (id 2447301909556127264), 1 bytes, with CRC32 of 0x399f7b69; got server CRC32 of 0x399f7b69
```

Клиент закончил передачу файла, подсчитал его контрольную сумму и сравнил с той,
что прислал сервер. Если суммы совпали, то в начале строки выводится "OK",
иначе "FAIL"; кроме того, клиент завершается с соответствующим кодом (0 при
успехе, 1 при неудаче).

# Проверки на утечки и некорректный доступ к памяти

Обе программы компилируются со включённым AddressSanitizer, который отслеживает
выходы за пределы массивов, use-after-free, double free и некоторые другие
ошибки.

Также я запускал сервер под Valgrind (`valgrind ./udpcpd localhost 8765`) и не
получил никаких предупреждений об утечках.
